<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>function</title>
<style type="text/css">
html,
body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
ol,
ul,
li,
img {
  margin: 0;
  padding: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
html * {
  font-family: "ff-din-web-pro-1", "ff-din-web-pro-2", sans-serif;
  font-size: 16px;
  line-height: 19.2px;
  color-profile: sRGB;
}
body {
  margin: 40px 70px;
}
p {
  font-weight: lighter;
  margin-bottom: 20px;
}
strong {
  font-weight: bold;
}
ol,
ul {
  margin-left: 2em;
  margin-bottom: 20px;
}
ul ul,
ol ol,
ul ol,
ol ul {
  margin-top: 10px;
}
li {
  margin-bottom: 10px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: lighter;
  text-transform: capitalize;
  margin-top: 40px;
  margin-bottom: 20px;
}
h1 {
  font-size: 24.624px;
  line-height: 29.548799999999996px;
}
h2 {
  font-size: 24.624px;
  line-height: 29.548799999999996px;
}
h3 {
  font-size: 23.44px;
  line-height: 28.128px;
}
h4 {
  font-size: 22.16px;
  line-height: 26.592px;
}
h5 {
  font-size: 22.16px;
  line-height: 26.592px;
}
h6 {
  font-size: 22.16px;
  line-height: 26.592px;
}
img {
  margin-bottom: 20px;
}
h1 img,
h2 img,
h3 img,
h4 img,
h5 img,
h6 img,
p img {
  margin-bottom: 0;
}
pre {
  margin-bottom: 20px;
}
pre,
code {
  font-family: monospace;
}
pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
  padding: 15px;
}
blockquote {
  border-left: 4px solid;
  padding: 0 15px;
}
blockquote > :first-child {
  margin-top: 0;
}
blockquote > :last-child {
  margin-bottom: 15px;
}
h1 {
  text-transform: uppercase;
  font-weight: bold;
  border-bottom: 1px solid;
}
h2 {
  border-bottom: 1px solid;
}
h3,
h4,
h5,
h6 {
  border-bottom: none;
}
html * {
  color: #657b83;
}
html body {
  background-color: #fdf6e3;
}
html h1,
html h2,
html h3,
html h4,
html h5,
html h6 {
  color: #586e75;
  border-color: #657b83;
}
html a,
html a:active,
html a:visited {
  color: #586e75;
}
html a:hover {
  background-color: #eee8d5;
}
html pre {
  color: #586e75;
  background-color: #eee8d5;
}
html a,
html a:active,
html a:visited,
html code.url {
  color: #b58900;
}
html h1 {
  color: #b58900;
}
html h2,
html h3,
html h4,
html h5,
html h6 {
  color: #b58900;
}

@media print {
  body {
    margin: 0;
  }
  * {
    color: #000 !important;
  }
}
</style>
<style type="text/css">
/**
 * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/chriskempson/tomorrow-theme
 * @author Rose Pritchard
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #ccc;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;

}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #2d2d2d;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #999;
}

.token.punctuation {
	color: #ccc;
}

.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
	color: #e2777a;
}

.token.function-name {
	color: #6196cc;
}

.token.boolean,
.token.number,
.token.function {
	color: #f08d49;
}

.token.property,
.token.class-name,
.token.constant,
.token.symbol {
	color: #f8c555;
}

.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
	color: #cc99cd;
}

.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
	color: #7ec699;
}

.token.operator,
.token.entity,
.token.url {
	color: #67cdcc;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

.token.inserted {
	color: green;
}
</style>
<style type="text/css">
pre.line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre.line-numbers > code {
	position: relative;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}
</style>
</head>
<body>
<h1 id="toc_0">Function</h1>

<p>Javascript设计得最出色的就是他的函数的实现。
函数就是对象，唯一与众不同的是它可以被调用。（没有重载）</p>

<h2 id="toc_1">函数定义</h2>

<h3 id="toc_2">函数声明</h3>

<pre class="line-numbers"><code class="language-javascript">function 函数名(形式参数) {
    函数功能实现
}</code></pre>

<h3 id="toc_3">函数表达式</h3>

<pre class="line-numbers"><code class="language-javascript">var 函数名 = function [函数名](形式参数) {
    函数功能实现
}</code></pre>

<p>此处函数名可省略，省略后被称为匿名函数表达式。</p>

<ul>
<li><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置.如果 function 是声明中 的第一个词,那么就是一个函数声明,否则就是一个函数表达式</p></li>
<li><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。函数表达式的标识符只有在函数内部才能访问。</p></li>
<li><p>尽量少使用匿名函数表达式。匿名函数在栈追踪中不会显示出有意义的函数名。函数名是对函数的自解释</p></li>
</ul>

<h3 id="toc_4">使用Function构造函数</h3>

<pre class="line-numbers"><code class="language-javascript">var 函数名 = new Function(形式参数, 函数体);</code></pre>

<p>传入值都是字符串类型，最后一个参数始终被看成函数体。
不推荐使用：</p>

<ul>
<li>不易于理解和维护</li>
<li>会造成两次代码解析 </li>
</ul>

<h3 id="toc_5">函数声明提升</h3>

<p>javascript引擎在执行前的解析阶段有一个“函数声明提升”的过程。把函数声明提升到作用域的顶部。<br>
当然变量声明也会提升，但函数声明具有比变量声明更高的优先级。</p>

<pre class="line-numbers"><code class="language-javascript">(function(){
    var test;
    function test() {console.log(&#39;test&#39;)};。
    console.log(typeof test);   // function
})();

(function(){
    function test() {console.log(&#39;test&#39;)};
    var test;
    console.log(typeof test);   // function
})()</code></pre>

<p><strong>除了函数声明，后面两种定义方式都不会有提升效果</strong></p>

<h2 id="toc_6">函数作用域</h2>

<p><del>ES6之前js只有函数作用域，没有块作用域。</del>ES6之前函数作用域是最常见的作用域单元，ES3开始就有块级作用域。</p>

<ul>
<li><p>with会创建块级作用域</p></li>
<li><p>try/catch 的 catch 分句会创建一个块作用域,其中声明的变量仅在 catch 内部有效</p></li>
</ul>

<pre class="line-numbers"><code class="language-javascript">try {
    throw undefined;
} catch (a) {
    a = 2;
    console.log( a );
}
console.log( a );</code></pre>

<h3 id="toc_7">闭包</h3>

<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。
函数定义内部可以自由访问把它嵌套在其中的父函数的参数与变量。</p>

<h2 id="toc_8">函数内部属性</h2>

<h3 id="toc_9">arguments</h3>

<p>arguments是个类数组对象(拥有数值索引和length属性)，包含这传入函数中的所有参数。</p>

<h4 id="toc_10">arguments.callee</h4>

<p>同时还有一个callee属性，是一个指向拥有这个arguments对象的函数。
<strong>在 ECMAScript 第五版 (ES5) 的 严格模式 中禁止使用 arguments.callee()。</strong></p>

<h4 id="toc_11">arguents.caller[已经废弃]</h4>

<p>使用arguments.callee.caller代替</p>

<h3 id="toc_12">this</h3>

<ul>
<li>全局运行上下文中(在任何函数体外部)，this指代全局对象。</li>
<li><p>在函数内部，this的取值取决于函数是如何调用的。</p>

<ul>
<li>直接调用：

<ul>
<li>非严格模式：this指向全局对象</li>
<li>严格模式：this为undefined</li>
</ul></li>
<li>对象方法中的this<br>
当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象. </li>
<li>构造函数中的this<br>
当一个函数被作为一个构造函数来使用（使用new关键字），它的this与即将被创建的新对象绑定。<br>
<strong>构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。</strong></li>
<li>call和apply<br>
通过所有函数都从Function对象的原型中继承的call()方法和apply()方法调用时，this的值可以绑定到一个指定的对象上。基本数据类型会被装箱，null和undefined会被忽略。</li>
<li>bind<br>
调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。基本数据类型会被装箱，null和undefined会被忽略。</li>
<li><p>DOM事件处理函数中的 this<br>
当函数被用作事件处理函数时，它的this指向触发事件的元素</p>

<pre class="line-numbers"><code class="language-javascript">// 被调用时，将关联的元素变成蓝色
function bluify(e){
  console.log(this === e.currentTarget); // 总是 true

  // 当 currentTarget 和 target 是同一个对象是为 true
  console.log(this === e.target);        
  this.style.backgroundColor = &#39;#A5D9F3&#39;;
}

// 获取文档中的所有元素的列表
var elements = document.getElementsByTagName(&#39;*&#39;);

// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色
for(var i=0 ; i&lt;elements.length ; i++){
  elements[i].addEventListener(&#39;click&#39;, bluify, false);
}</code></pre></li>
<li><p>内联事件处理函数中的 this<br>
当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素</p>

<pre class="line-numbers"><code class="language-javascript">&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt;&lt;/button&gt;</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_13">this判定的优先级</h4>

<ol>
<li><p>函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。</p>

<pre class="line-numbers"><code class="language-javascript">function foo() { 
    console.log(this.a);
}
var o= {a: 3};
var fooBind = foo.bind(o)
fooBind(); // 3
new fooBind(); // undefined</code></pre></li>
<li><p>函数是否通过call、apply(显式绑定)或者bind(硬绑定)调用?如果是的话,this绑定的是 指定的对象。</p></li>
<li><pre class="line-numbers"><code class="language-javascript">function foo() { 
    console.log(this.a);
}
var o= {a: 3};
var fooBind = foo.bind(o)
fooBind(); // 3
fooBind.call({a: 4}); // 3</code></pre></li>
<li><p>函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上 下文对象。</p></li>
<li><p>如果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。</p></li>
<li><p><strong>例外</strong></p>

<ol>
<li><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind,这些值在调用时会被忽略,实际应用的是默认绑定规则**</p>

<pre class="line-numbers"><code class="language-javascript">function foo(p1,p2) {
    this.val = p1 + p2;
}
var bar = foo.bind( null, &quot;p1&quot; );
var baz = {
    bar: bar
};
baz.bar( &quot;p2&quot; );
console.log(baz.val); // undefined
console.log(window.val); //p1p2</code></pre>

<p>总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this(比如第三方库中的一个函数),那默认绑定规则会把 this 绑定到全局对象(在浏览 器中这个对象是 window),这将导致不可预计的后果(比如修改全局对象)。</p>

<p>可以使用Object.create(null)，它和 {} 很像,但是并不会创建 Object.prototype 这个委托,所以它比 {}“更空。</p></li>
<li><p>间接引用</p>

<pre class="line-numbers"><code class="language-javascript">function foo() { 
    console.log(this.a);
}
var a = 2;
var o = { a: 3, foo: foo }; 
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 2</code></pre></li>
<li><p>软绑定：</p>

<pre class="line-numbers"><code class="language-javascript">Function.prototype.softBind = function(obj) {
    var fn = this;
    // 捕获所有 curried 参数
    var curried = [].slice.call(arguments, 1);
    var bound = function() {
        return fn.apply(
            (!this || this === (window || global)) ? obj : this,
            curried.concat.apply(curried, arguments)
         ); 
    };
    bound.prototype = fn.prototype;
    return bound; 
};</code></pre></li>
</ol></li>
</ol>

<h2 id="toc_14">函数属性</h2>

<ul>
<li>length<br>
length 属性指明函数的形参个数。</li>
<li>caller[非标准，不建议使用]<br>
返回调用指定函数的函数。<br>
如果一个函数f是在全局作用域内被调用的,则f.caller为null。</li>
<li>name[非标准，不建议使用]<br>
返回函数的函数名称。</li>
<li>prototype<br>
存储了 Function 的原型对象。</li>
<li>这些属性都不可列举，即enumerable为false</li>
</ul>

<h2 id="toc_15">函数方法</h2>

<ul>
<li><p>Function.prototype.apply(thisArg[, argsArray])<br>
在指定 this 值和参数的情况下调用某个函数。</p>

<p><strong>argsArray</strong>可以是<a href="https://segmentfault.com/a/1190000000415572">类数组</a>(arguments...)。</p>

<pre class="line-numbers"><code class="language-javascript">function foo() {
    console.log(arguments);
}
foo.apply({}, {0:1, 1:2, length: 2}); // [1,2]</code></pre></li>
<li><p>Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])<br>
在指定的this值和若干个指定的参数值的前提下调用某个函数或方法。</p></li>
<li><p>Function.prototype.bind(thisArg[, arg1[, arg2[, ...]]])<br>
bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p></li>
<li><p>Function.prototype.toString()<br>
返回一个表示当前函数源代码的字符串</p></li>
</ul>

<h2 id="toc_16">函数递归</h2>

<p>一个函数在自身内部调用自身：</p>

<ul>
<li>通过使用函数名<br></li>
<li>使用作用域下的一个变量名来指向函数</li>
<li>使用arguments.callee(不推荐)</li>
</ul>

<script type="text/javascript">
self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var s={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var l in a)a.hasOwnProperty(l)&&(s[l]=a[l]);s[o]=i[o]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=s)}),r[e]=s},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,s,o=a;o&&!e.test(o.className);)o=o.parentNode;if(o&&(l=(o.className.match(e)||[,""])[1],s=t.languages[l]),s){a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=a.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var u=a.textContent;if(u){u=u.replace(/^(?:\r?\n|\r)/,"");var g={element:a,language:l,grammar:s,code:u};if(t.hooks.run("before-highlight",g),r&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){g.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(g.element),t.hooks.run("after-highlight",g)},c.postMessage(JSON.stringify({language:g.language,code:g.code}))}else g.highlightedCode=t.highlight(g.code,g.grammar,g.language),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(a),t.hooks.run("after-highlight",g)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var s=n[l];s="Array"===t.util.type(s)?s:[s];for(var o=0;o<s.length;++o){var u=s[o],g=u.inside,c=!!u.lookbehind,f=0,h=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){u.lastIndex=0;var m=u.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),N=[p,1];b&&N.push(b);var O=new a(l,g?t.tokenize(m,g):m,h);N.push(O),w&&N.push(w),Array.prototype.splice.apply(r,N)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("Array"===t.util.type(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var i={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run("wrap",i);var s="";for(var o in i.attributes)s+=o+'="'+(i.attributes[o]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+s+">"+i.content+"</"+i.tag+">"},!self.document)return self.addEventListener?(self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism);
</script>
<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.+/,lookbehind:!0}],string:/("|')(\\\n|\\?.)*?\1/,"class-name":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":{pattern:/[a-z0-9_]+\(/i,inside:{punctuation:/\(/}},number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/,operator:/[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|~|\^|%/,ignore:/&(lt|gt|amp);/i,punctuation:/[{}[\];(),.:]/};
</script>
<script type="text/javascript">
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|-?Infinity)\b/,"function":/(?!\d)[a-z0-9_$]+(?=\()/i}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,lookbehind:!0}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/<script[\w\W]*?>[\w\W]*?<\/script>/i,inside:{tag:{pattern:/<script[\w\W]*?>|<\/script>/i,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript},alias:"language-javascript"}});
</script>
<script type="text/javascript">
Prism.hooks.add("after-highlight",function(e){var n=e.element.parentNode;if(n&&/pre/i.test(n.nodeName)&&-1!==n.className.indexOf("line-numbers")){var t,a=1+e.code.split("\n").length;lines=new Array(a),lines=lines.join("<span></span>"),t=document.createElement("span"),t.className="line-numbers-rows",t.innerHTML=lines,n.hasAttribute("data-start")&&(n.style.counterReset="linenumber "+(parseInt(n.getAttribute("data-start"),10)-1)),e.element.appendChild(t)}});
</script>
</body>

</html>
