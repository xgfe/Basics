<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>ES6 Function</title>
<style type="text/css">
html,
body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
ol,
ul,
li,
img {
  margin: 0;
  padding: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
html * {
  font-family: "ff-din-web-pro-1", "ff-din-web-pro-2", sans-serif;
  font-size: 16px;
  line-height: 19.2px;
  color-profile: sRGB;
}
body {
  margin: 40px 70px;
}
p {
  font-weight: lighter;
  margin-bottom: 20px;
}
strong {
  font-weight: bold;
}
ol,
ul {
  margin-left: 2em;
  margin-bottom: 20px;
}
ul ul,
ol ol,
ul ol,
ol ul {
  margin-top: 10px;
}
li {
  margin-bottom: 10px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: lighter;
  text-transform: capitalize;
  margin-top: 40px;
  margin-bottom: 20px;
}
h1 {
  font-size: 24.624px;
  line-height: 29.548799999999996px;
}
h2 {
  font-size: 24.624px;
  line-height: 29.548799999999996px;
}
h3 {
  font-size: 23.44px;
  line-height: 28.128px;
}
h4 {
  font-size: 22.16px;
  line-height: 26.592px;
}
h5 {
  font-size: 22.16px;
  line-height: 26.592px;
}
h6 {
  font-size: 22.16px;
  line-height: 26.592px;
}
img {
  margin-bottom: 20px;
}
h1 img,
h2 img,
h3 img,
h4 img,
h5 img,
h6 img,
p img {
  margin-bottom: 0;
}
pre {
  margin-bottom: 20px;
}
pre,
code {
  font-family: monospace;
}
pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
  padding: 15px;
}
blockquote {
  border-left: 4px solid;
  padding: 0 15px;
}
blockquote > :first-child {
  margin-top: 0;
}
blockquote > :last-child {
  margin-bottom: 15px;
}
h1 {
  text-transform: uppercase;
  font-weight: bold;
  border-bottom: 1px solid;
}
h2 {
  border-bottom: 1px solid;
}
h3,
h4,
h5,
h6 {
  border-bottom: none;
}
html * {
  color: #657b83;
}
html body {
  background-color: #fdf6e3;
}
html h1,
html h2,
html h3,
html h4,
html h5,
html h6 {
  color: #586e75;
  border-color: #657b83;
}
html a,
html a:active,
html a:visited {
  color: #586e75;
}
html a:hover {
  background-color: #eee8d5;
}
html pre {
  color: #586e75;
  background-color: #eee8d5;
}
html a,
html a:active,
html a:visited,
html code.url {
  color: #b58900;
}
html h1 {
  color: #b58900;
}
html h2,
html h3,
html h4,
html h5,
html h6 {
  color: #b58900;
}

@media print {
  body {
    margin: 0;
  }
  * {
    color: #000 !important;
  }
}
</style>
<style type="text/css">
/**
 * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/chriskempson/tomorrow-theme
 * @author Rose Pritchard
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #ccc;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;

}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #2d2d2d;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #999;
}

.token.punctuation {
	color: #ccc;
}

.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
	color: #e2777a;
}

.token.function-name {
	color: #6196cc;
}

.token.boolean,
.token.number,
.token.function {
	color: #f08d49;
}

.token.property,
.token.class-name,
.token.constant,
.token.symbol {
	color: #f8c555;
}

.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
	color: #cc99cd;
}

.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
	color: #7ec699;
}

.token.operator,
.token.entity,
.token.url {
	color: #67cdcc;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

.token.inserted {
	color: green;
}
</style>
<style type="text/css">
pre.line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre.line-numbers > code {
	position: relative;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}
</style>
</head>
<body>
<h1 id="toc_0">ES6 Function</h1>

<h2 id="toc_1">箭头函数</h2>

<p>使用“箭头”（=&gt;）定义函数。</p>

<pre class="line-numbers"><code class="language-javascript">var f = v =&gt; v;

// ES 5
var f = function(v) {
  return v;
};</code></pre>

<ul>
<li><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>

<pre class="line-numbers"><code class="language-javascript">var f = () =&gt; 5;
var sum = (num1, num2) =&gt; num1 + num2;</code></pre></li>
<li><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回</p>

<pre class="line-numbers"><code class="language-javascript">var sum = (num1, num2) =&gt; { return num1 + num2; }</code></pre></li>
<li><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号</p>

<pre class="line-numbers"><code class="language-javascript">var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });</code></pre></li>
</ul>

<h3 id="toc_2">使用注意事项</h3>

<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象：解释说箭头函数没有this变量</li>
<li><p>call, apply, bind无法改变this</p>

<pre class="line-numbers"><code class="language-javascript">var foo = () =&gt; console.log(this);
foo.call({a:123});      // window
foo.apply({a:123});     // window
foo.bind({a:123})();    // window</code></pre></li>
<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。【纯词法作用域的this和arguments,可看做普通变量】</p></li>
<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</p></li>
<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数</p></li>
<li><p>形参和=&gt;之间不能换行，否则会报语法错误</p>

<pre class="line-numbers"><code class="language-javascript">Function(&quot;x\n =&gt; 2&quot;); // Uncaught SyntaxError: Unexpected token =&gt;</code></pre></li>
<li><p>逻辑运算优先级高于箭头函数</p>

<pre class="line-numbers"><code class="language-javascript">0 || () =&gt; 2; // Uncaught SyntaxError: Unexpected token )</code></pre></li>
<li><p>没有prototype属性</p></li>
<li><p>内部也没有super, new.target绑定</p></li>
</ul>

<h2 id="toc_3">参数默认值定义</h2>

<p>使用默认参数，在函数体的检查就不再需要了</p>

<pre class="line-numbers"><code class="language-javascript">function multiply(a, b = 1) {
    return a*b;
}

multiply(5); // 5</code></pre>

<ul>
<li><p>定义了默认值的参数，如果传入的是undefined将使用默认值</p>

<pre class="line-numbers"><code class="language-javascript">function multiply(a, b = 2) {
    return a*b;
}

multiply(5, undefined); // 10</code></pre></li>
<li><p>默认参数可以使用前面的参数</p>

<pre class="line-numbers"><code class="language-javascript">function multiply(a, b = a) {
    return a*b;
}

multiply(5); // 25</code></pre></li>
<li><p>arguments不包含默认参数(调用时传入啥就是啥)</p>

<pre class="line-numbers"><code class="language-javascript">function test(a = 1, b = 2, c = 3) {
    console.log(arguments);
}

test();             // []
test(1);            // [1]
test(undefined);    // [undefined]</code></pre></li>
<li><p>TEMPORAL DEAD ZONE(TDZ)</p>

<pre class="line-numbers"><code class="language-javascript">var x = &#39;outer scope x&#39;;
var y = &#39;outer scope y&#39;
(function() {
    console.log(x);     // undefined
    console.log(y);     // ReferenceError: y is not defined
    var x = &#39;inner scope x&#39;;
    let y = &#39;inner scope y&#39;;
}());</code></pre></li>
<li><p>分隔的作用域</p>

<pre class="line-numbers"><code class="language-javascript">(function() {
    var outer = 123;
    (function(a = function() {
        console.log(&#39;outer:&#39;, typeof outer);    // number
        console.log(&#39;inner:&#39;, typeof inner);    // undefined
    }) {
        var inner = 1;
        a();
    } ())
} ())</code></pre></li>
<li><p>new Function支持</p>

<pre class="line-numbers"><code class="language-javascript">new Function(&#39;a = 1&#39;, &#39;b = 2&#39;, &#39;return a*b;&#39;)();    // 2</code></pre></li>
<li><p>定义了默认参数的参数将不记入function.length中</p>

<pre class="line-numbers"><code class="language-javascript">(function(a){}).length // 1
(function(a = 5){}).length // 0
(function(a, b, c = 5){}).length // 2</code></pre></li>
<li><p>还可以利用此特性设置某些参数不可省略</p>

<pre class="line-numbers"><code class="language-javascript">function throwIfMissing() {
  throw new Error(&#39;Missing parameter&#39;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter</code></pre></li>
</ul>

<h2 id="toc_4">剩余参数(rest)</h2>

<p>剩余参数语法允许将不确定数量的参数表示为数组。</p>

<pre class="line-numbers"><code class="language-javascript">function multiply(multiplier, ...theArgs) {
    return theArgs.map(x =&gt; multiplier * x);
}

var arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]</code></pre>

<ul>
<li><p>剩余参数同样也不记入function.length中</p>

<pre class="line-numbers"><code class="language-javascript">function multiply(multiplier, ...theArgs) {
    return theArgs.map(x =&gt; multiplier * x);
}

console.log(multiply.length); // 1</code></pre></li>
<li><p>不能在setters中使用</p>

<pre class="line-numbers"><code class="language-javascript">var obj = {
    set e(...args) {
        this._e = args;
    },
    get e() {
        return this._e;
    }
};
// SyntaxError: Setter must have exactly one formal parameter.</code></pre></li>
<li><p>new Function支持</p>

<pre class="line-numbers"><code class="language-javascript">new Function(&#39;a&#39;, &#39;...b&#39;, &#39;console.log(b)&#39;)(1,2,3,4);    // [2, 3, 4]</code></pre></li>
</ul>

<h2 id="toc_5">扩展运算符...</h2>

<p>它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>

<pre class="line-numbers"><code class="language-javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5</code></pre>

<p>应用：</p>

<ul>
<li><p>合并数组</p>

<pre class="line-numbers"><code class="language-javascript">// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]</code></pre></li>
<li><p>字符串转化成数组</p>

<pre class="line-numbers"><code class="language-javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</code></pre></li>
</ul>

<h2 id="toc_6">name属性</h2>

<p>这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。<br>
* 如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名</p>

<pre><code>```javascript
var func1 = function () {};

// ES5
func1.name // &quot;&quot;

// ES6
func1.name // &quot;func1&quot;
```</code></pre>

<ul>
<li><p>如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。</p>

<pre class="line-numbers"><code class="language-javascript">const bar = function baz() {};

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;</code></pre></li>
<li><p>bind返回的函数，name属性值会加上“bound ”前缀</p>

<pre class="line-numbers"><code class="language-javascript">function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;</code></pre></li>
<li><p>Function构造函数返回的函数实例，name属性的值为“anonymous”</p>

<pre class="line-numbers"><code class="language-javascript">(new Function).name // &quot;anonymous&quot;</code></pre></li>
<li><p>对象中的方法</p>

<pre class="line-numbers"><code class="language-javascript">var o = { foo: function(){}, bar: function baz(){}};
o.qux = function(){};
    o.foo.name === &quot;foo&quot; &amp;&amp;
    o.bar.name === &quot;baz&quot; &amp;&amp;
    o.qux.name === &quot;&quot;;</code></pre></li>
<li><p>getter和setter</p>

<pre class="line-numbers"><code class="language-javascript">var o = { get foo(){}, set foo(x){} };
var descriptor = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);
descriptor.get.name === &quot;get foo&quot; &amp;&amp;
descriptor.set.name === &quot;set foo&quot;;</code></pre></li>
<li><p>对象简写</p>

<pre class="line-numbers"><code class="language-javascript">var o = { foo(){} };
o.foo.name === &quot;foo&quot;;

var f = &quot;foo&quot;;
({f() { return f; }}).f() === &quot;foo&quot;;</code></pre></li>
<li><p>[*]Symbol作为key的方法</p>

<pre class="line-numbers"><code class="language-javascript">var sym1 = Symbol(&quot;foo&quot;);
var sym2 = Symbol();
var o = {
  [sym1]: function(){},
  [sym2]: function(){}
};

o[sym1].name === &quot;[foo]&quot; &amp;&amp;
o[sym2].name === &quot;&quot;;</code></pre></li>
<li><p>class申明中的name</p>

<pre class="line-numbers"><code class="language-javascript">class foo {};
class bar { static name() {} };
foo.name === &quot;foo&quot; &amp;&amp;
typeof bar.name === &quot;function&quot;;</code></pre></li>
<li><p>class表达式中的name与申明保持一致</p></li>
<li><p>经class表达式赋值后的变量的name</p>

<pre class="line-numbers"><code class="language-javascript">var foo = class {};
var bar = class baz {};
var qux = class { static name() {} };
foo.name === &quot;foo&quot; &amp;&amp;
bar.name === &quot;baz&quot; &amp;&amp;
typeof qux.name === &quot;function&quot;;</code></pre></li>
<li><p>对象中的class表达式name</p>

<pre class="line-numbers"><code class="language-javascript">var o = { foo: class {}, bar: class baz {}};
o.qux = class {};
o.foo.name === &quot;foo&quot; &amp;&amp;
o.bar.name === &quot;baz&quot; &amp;&amp;
o.qux.name === &quot;&quot;;</code></pre></li>
<li><p>原型链上的方法和静态方法的name</p>

<pre class="line-numbers"><code class="language-javascript">class C { foo(){} };
(new C).foo.name === &quot;foo&quot;;

class C { static foo(){} };
C.foo.name === &quot;foo&quot;;</code></pre></li>
<li><p>name的描述属性</p>

<pre class="line-numbers"><code class="language-javascript">var descriptor = Object.getOwnPropertyDescriptor(function f(){},&quot;name&quot;);
descriptor.enumerable   === false &amp;&amp;
descriptor.writable     === false &amp;&amp;
descriptor.configurable === true; //不可写，不可枚举，可配置，可删除</code></pre>

<h2 id="toc_7">Function是可继承的</h2></li>
<li><p>继承Function的类可以通过new正常调用创建function，并拥有正确的原型链</p>

<pre class="line-numbers"><code class="language-javascript">class C extends Function {}
var c = new C(&quot;return &#39;foo&#39;;&quot;);
c() === &#39;foo&#39;;
c instanceof C &amp;&amp; c instanceof Function &amp;&amp; Object.getPrototypeOf(C) === Function;</code></pre></li>
<li><p>通过继承的类创建的function可以使用new调用，也可以调用原型链上的call, apply, bind方法</p></li>
</ul>

<h2 id="toc_8">Bound Function的prototype</h2>

<ul>
<li><p>bind不会改变函数的原型</p>

<pre class="line-numbers"><code class="language-javascript">function correctProtoBound(proto) {
    var f = function(){};
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(f, proto);
    } else {
        f.__proto__ = proto;
    }
    var boundF = Function.prototype.bind.call(f, null);
    return Object.getPrototypeOf(boundF) === proto;
}
correctProtoBound(Function.prototype) &amp;&amp; correctProtoBound({}) &amp;&amp; correctProtoBound(null);</code></pre></li>
<li><p>generator, arrow function, class, subclass bind后原型也都不会改变</p></li>
</ul>

<h2 id="toc_9">function的length属性是可配置的</h2>

<pre class="line-numbers"><code class="language-javascript">var fn = function(a, b) {};

var desc = Object.getOwnPropertyDescriptor(fn, &quot;length&quot;);
if (desc.configurable) {
    Object.defineProperty(fn, &quot;length&quot;, { value: 1 });
    fn.length === 1;
}</code></pre>

<h2 id="toc_10">尾调用优化</h2>

<p>第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”，这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>

<pre class="line-numbers"><code class="language-javascript">// 尾调用
function f(x){
    return g(x);
}
// 尾递归
function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
}</code></pre>

<p>尾调用和尾递归优化后的调用栈深度始终为1，因为在进行尾部函数调用的时候前面的函数调用环境已经销毁，节省内存开销，不会发生栈溢出。</p>

<script type="text/javascript">
self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var s={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var l in a)a.hasOwnProperty(l)&&(s[l]=a[l]);s[o]=i[o]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=s)}),r[e]=s},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,s,o=a;o&&!e.test(o.className);)o=o.parentNode;if(o&&(l=(o.className.match(e)||[,""])[1],s=t.languages[l]),s){a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=a.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var u=a.textContent;if(u){u=u.replace(/^(?:\r?\n|\r)/,"");var g={element:a,language:l,grammar:s,code:u};if(t.hooks.run("before-highlight",g),r&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){g.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(g.element),t.hooks.run("after-highlight",g)},c.postMessage(JSON.stringify({language:g.language,code:g.code}))}else g.highlightedCode=t.highlight(g.code,g.grammar,g.language),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(a),t.hooks.run("after-highlight",g)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var s=n[l];s="Array"===t.util.type(s)?s:[s];for(var o=0;o<s.length;++o){var u=s[o],g=u.inside,c=!!u.lookbehind,f=0,h=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){u.lastIndex=0;var m=u.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),N=[p,1];b&&N.push(b);var O=new a(l,g?t.tokenize(m,g):m,h);N.push(O),w&&N.push(w),Array.prototype.splice.apply(r,N)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("Array"===t.util.type(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var i={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run("wrap",i);var s="";for(var o in i.attributes)s+=o+'="'+(i.attributes[o]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+s+">"+i.content+"</"+i.tag+">"},!self.document)return self.addEventListener?(self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism);
</script>
<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.+/,lookbehind:!0}],string:/("|')(\\\n|\\?.)*?\1/,"class-name":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":{pattern:/[a-z0-9_]+\(/i,inside:{punctuation:/\(/}},number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/,operator:/[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|~|\^|%/,ignore:/&(lt|gt|amp);/i,punctuation:/[{}[\];(),.:]/};
</script>
<script type="text/javascript">
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|-?Infinity)\b/,"function":/(?!\d)[a-z0-9_$]+(?=\()/i}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,lookbehind:!0}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/<script[\w\W]*?>[\w\W]*?<\/script>/i,inside:{tag:{pattern:/<script[\w\W]*?>|<\/script>/i,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript},alias:"language-javascript"}});
</script>
<script type="text/javascript">
Prism.hooks.add("after-highlight",function(e){var n=e.element.parentNode;if(n&&/pre/i.test(n.nodeName)&&-1!==n.className.indexOf("line-numbers")){var t,a=1+e.code.split("\n").length;lines=new Array(a),lines=lines.join("<span></span>"),t=document.createElement("span"),t.className="line-numbers-rows",t.innerHTML=lines,n.hasAttribute("data-start")&&(n.style.counterReset="linenumber "+(parseInt(n.getAttribute("data-start"),10)-1)),e.element.appendChild(t)}});
</script>
</body>

</html>
