<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>Symbol</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
</head>
<body>
<h1 id="toc_0">Symbol</h1>

<h3 id="toc_1">背景</h3>

<p>ES5及之前的对象属性名都是字符串，这样容易造成属性名的冲突。为了防止这一问题，保证每个属性的名字是独一无二的，因此ES6中引入了Symbol。</p>

<p>原始数据类型Symbol是继 Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）之外的第七种数据类型，表示独一无二的值。</p>

<h3 id="toc_2">声明</h3>

<p>Symbol值是由<code>Symbol</code>函数生成，这样对象的属性名既可以是字符串类型，又可以是Symbol值。凡是Symbol类型的，都是独一无二不会和其他属性名产生冲突的。</p>

<pre><code class="language-none">Symbol([description])</code></pre>

<p>其中，description是一个字符串，用来描述符号，用于调试而不是访问符号本身。因此相同参数的Symbol函数的返回值实不相等的。</p>

<p>以下是Symbol的几个特点：</p>

<ul>
<li>Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</li>
</ul>

<pre><code class="language-none">var sym = new Symbol(); // TypeError</code></pre>

<ul>
<li>Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</li>
</ul>

<pre><code class="language-none">// 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2 // false

// 有参数的情况
var s1 = Symbol(&quot;foo&quot;);
var s2 = Symbol(&quot;foo&quot;);

s1 === s2 // false</code></pre>

<ul>
<li>Symbol值不能与其他类型的值进行运算，会报错。</li>
</ul>

<pre><code class="language-none">var sym = Symbol(&#39;My symbol&#39;);

&quot;your symbol is &quot; + sym
// TypeError: can&#39;t convert symbol to string
`your symbol is ${sym}`
// TypeError: can&#39;t convert symbol to string</code></pre>

<ul>
<li>Symbol可以显示转化为字符串和布尔值。</li>
</ul>

<pre><code class="language-none">var sym = Symbol(&#39;My symbol&#39;);
String(sym) // &#39;Symbol(My symbol)&#39;
sym.toString() // &#39;Symbol(My symbol)&#39;

var sym = Symbol();
Boolean(sym)// true
!sym  // false</code></pre>

<h3 id="toc_3">作为属性名</h3>

<p>为了使对象的属性不出现同名的情况，可以用Symbol作为标识符。</p>

<pre><code class="language-none">var mySymbol = Symbol();

// 第一种写法
var a = {};
a[mySymbol] = &#39;Hello!&#39;;

// 第二种写法
var a = {

};

// 第三种写法
var a = {};
Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });

// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;</code></pre>

<p><strong>当Symbol作为标识符时，不能用点运算符。</strong></p>

<p>1.因为点运算符后面总是字符串。 </p>

<pre><code class="language-none">var mySymbol = Symbol();
var a = {};

a.mySymbol = &#39;Hello!&#39;;
a[mySymbol] // undefined
a[&#39;mySymbol&#39;] // &quot;Hello!&quot;</code></pre>

<p>2.在对象内部，定义时必须在方括号中。</p>

<pre><code class="language-none">let s = Symbol();

let obj = {
  [s]: function (arg) { ... }
};

obj[s](123);</code></pre>

<h3 id="toc_4">定义一组值不相等的常量</h3>

<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都不相等。</p>

<pre><code class="language-none">const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();

function getComplement(color) {
  switch (color) {
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_GREEN:
      return COLOR_RED;
    default:
      throw new Error(&#39;Undefined color&#39;);
    }
}</code></pre>

<p>常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。</p>

<h3 id="toc_5">Symbol的遍历</h3>

<p>当Symbol作为属性名时，不会出现在<code>for...in</code>、<code>for...of</code>中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>。它不是私有属性，可以利用<code>Object.getOwnPropertySymbols</code>方法返回对象的所有Symbol属性名。</p>

<pre><code class="language-none">var obj = {};
var a = Symbol(&#39;a&#39;);
var b = Symbol.for(&#39;b&#39;);

obj[a] = &#39;Hello&#39;;
obj[b] = &#39;World&#39;;

var objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols
// [Symbol(a), Symbol(b)]</code></pre>

<p><strong>利用新的API，<code>Reflect.ownKeys</code>可以返回所有类型的键名，包括Symbol键名</strong></p>

<pre><code class="language-none">let obj = {

  enum: 2,
  nonEnum: 3
};

Reflect.ownKeys(obj)
// [Symbol(my_key), &#39;enum&#39;, &#39;nonEnum&#39;]</code></pre>

<h3 id="toc_6">Symbol类型的方法</h3>

<h4 id="toc_7">Symbol.for()</h4>

<p>有时希望重新用同一个Symbol的值，<code>Symbol.for</code>方法接收一个字符串作为参数，然后搜索是否有以该参数作为名称的Symbol值，如果有则返回这个Symbol值，如果没有则新建并返回以这个字符串作为参数的Symbol值。</p>

<pre><code class="language-none">var s1 = Symbol.for(&#39;foo&#39;);
var s2 = Symbol.for(&#39;foo&#39;);
s1 === s2 // true

var s1 = Symbol(&#39;foo&#39;);
var s2 = Symbol.for(&#39;foo&#39;);
s1 === s2 // false</code></pre>

<p>Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。</p>

<h4 id="toc_8">Symbol.keyFor()</h4>

<p><code>Symbol.keyFor</code>返回一个<code>已登记</code>的Symbol类型值的key。</p>

<pre><code class="language-none">var s1 = Symbol.for(&quot;foo&quot;);
Symbol.keyFor(s1) // &quot;foo&quot;

var s2 = Symbol(&quot;foo&quot;);
Symbol.keyFor(s2) // undefined</code></pre>

<p>上面代码中，变量s2属于未登记的Symbol值，所以返回undefined。</p>

<h3 id="toc_9">内置的Symbol值</h3>

<p>除了自定义的Symbol值外，ES6还提供了11个内置的Symbol值，它们都是对象的属性，指向语言内部使用的方法。</p>

<h4 id="toc_10">Symbol.hasInstance</h4>

<p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。该对象使用<code>instanceof</code>运算符时，会调用这个方法，判断该对象是否为某个构造函数的实例。比如，foo instanceof Foo在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>

<pre><code class="language-none">class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array;
  }
}

[1, 2, 3] instanceof MyClass // true</code></pre>

<h4 id="toc_11">Symbol.isConcatSpreadable</h4>

<p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开。</p>

<pre><code class="language-none">let arr1 = [&#39;c&#39;, &#39;d&#39;];
[&#39;a&#39;, &#39;b&#39;].concat(arr1, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]

let arr2 = [&#39;c&#39;, &#39;d&#39;];
arr2[Symbol.isConcatSpreadable] = false;
[&#39;a&#39;, &#39;b&#39;].concat(arr2, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]</code></pre>

<p>上面代码说明，数组的<code>Symbol.isConcatSpreadable</code>属性默认为<code>true</code>，表示可以展开。</p>

<p>类似数组的对象也可以展开，但它的<code>Symbol.isConcatSpreadable</code>属性默认为<code>false</code>，必须手动打开。</p>

<pre><code class="language-none">let obj = {length: 2, 0: &#39;c&#39;, 1: &#39;d&#39;};
[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]

obj[Symbol.isConcatSpreadable] = true;
[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre>

<p>对于一个类来说，<code>Symbol.isConcatSpreadable</code>属性必须写成一个返回布尔值的方法。</p>

<pre><code class="language-none">class A1 extends Array {
  [Symbol.isConcatSpreadable]() {
    return true;
  }
}
class A2 extends Array {
  [Symbol.isConcatSpreadable]() {
    return false;
  }
}
let a1 = new A1();
a1[0] = 3;
a1[1] = 4;
let a2 = new A2();
a2[0] = 5;
a2[1] = 6;
[1, 2].concat(a1).concat(a2)
// [1, 2, 3, 4, [5, 6]]</code></pre>

<h4 id="toc_12">Symbol.iterator</h4>

<p>最重要的一个就是Symbol.iterator，相当于迭代器的接口。只有对象中有这个symbol的属性，才认为这个对象是可以迭代的。</p>

<pre><code class="language-none">var students = {}

students[Symbol.iterator] = function() {
  let index = 1;
  return {
    next() {
      return {done: index&gt;100, value: index++}
    }
  }
}

for(var i of students) {
  console.log(i);
}</code></pre>

<p>当执行 for(var i of students) 的时候，其实是调用了 <code>students[Symbol.iterator]()</code> 方法，这个方法返回了一个iterator（迭代器）。迭代器有一个next方法，for循环会不断调用这个 iterator.next方法来获取下一个值，直到返回值中的 done 属性为true的时候结束循环。</p>

<h4 id="toc_13">Symbol.species</h4>

<p>对象的<code>Symbol.species</code>属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果<code>this.constructor[Symbol.species]</code>存在，就会使用这个属性作为构造函数，来创造新的实例对象。</p>

<p><code>Symbol.species</code>属性默认的读取器如下。</p>

<pre><code class="language-none">static get [Symbol.species]() {
  return this;
}</code></pre>

<h4 id="toc_14">Symbol.match</h4>

<p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>

<pre><code class="language-none">String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)

class MyMatcher {
  [Symbol.match](string) {
    return &#39;hello world&#39;.indexOf(string);
  }
}
&#39;e&#39;.match(new MyMatcher()) // 1</code></pre>

<h4 id="toc_15">Symbol.replace</h4>

<p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>

<pre><code class="language-none">String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)</code></pre>

<h4 id="toc_16">Symbol.search</h4>

<p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>

<pre><code class="language-none">String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)

class MySearch {
  constructor(value) {
    this.value = value;
  }
  [Symbol.search](string) {
    return string.indexOf(this.value);
  }
}
&#39;foobar&#39;.search(new MySearch(&#39;foo&#39;)) // 0</code></pre>

<h4 id="toc_17">Symbol.split</h4>

<p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>

<pre><code class="language-none">String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)</code></pre>

<h4 id="toc_18">Symbol.iterator</h4>

<p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法，即该对象进行<code>for...of</code>循环时，会调用这个方法，返回该对象的默认遍历器。</p>

<pre><code class="language-none">class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2</code></pre>

<h4 id="toc_19">Symbol.toPrimitive</h4>

<p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>

<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>

<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串</li>
</ul>

<pre><code class="language-none">let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case &#39;number&#39;:
        return 123;
      case &#39;string&#39;:
        return &#39;str&#39;;
      case &#39;default&#39;:
        return &#39;default&#39;;
      default:
        throw new Error();
     }
   }
};

2 * obj // 246
3 + obj // &#39;3default&#39;
obj === &#39;default&#39; // true
String(obj) // &#39;str&#39;</code></pre>

<h4 id="toc_20">Symbol.toStringTag</h4>

<p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中object后面的那个字符串。</p>

<pre><code class="language-none">({[Symbol.toStringTag]: &#39;Foo&#39;}.toString())
// &quot;[object Foo]&quot;

class Collection {
  get [Symbol.toStringTag]() {
    return &#39;xxx&#39;;
  }
}
var x = new Collection();
Object.prototype.toString.call(x) // &quot;[object xxx]&quot;</code></pre>

<p>ES6新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>

<ul>
<li><code>JSON[Symbol.toStringTag]</code>：&#39;JSON&#39;</li>
<li><code>Math[Symbol.toStringTag]</code>：&#39;Math&#39;</li>
<li><code>Module对象[Symbol.toStringTag]</code>：&#39;Module&#39;</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：&#39;ArrayBuffer&#39;</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：&#39;DataView&#39;</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：&#39;Map&#39;</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：&#39;Promise&#39;</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：&#39;Set&#39;</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：&#39;Uint8Array&#39;等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：&#39;WeakMap&#39;</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：&#39;WeakSet&#39;</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：&#39;Map Iterator&#39;</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：&#39;Set Iterator&#39;</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：&#39;String Iterator&#39;</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：&#39;Symbol&#39;</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：&#39;Generator&#39;</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：&#39;GeneratorFunction&#39;</li>
</ul>

<h4 id="toc_21">Symbol.unscopables</h4>

<p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>

<pre><code class="language-none">Array.prototype[Symbol.unscopables]
// {
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   keys: true
// }

Object.keys(Array.prototype[Symbol.unscopables])
// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;keys&#39;]</code></pre>

<p>上面代码说明，数组有6个属性，会被with命令排除。</p>

<pre><code class="language-none">// 没有unscopables时
class MyClass {
  foo() { return 1; }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 1
}

// 有unscopables时
class MyClass {
  foo() { return 1; }
  get [Symbol.unscopables]() {
    return { foo: true };
  }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 2
}</code></pre>

<h3 id="toc_22">应用</h3>

<p>魔术贴属性VS私有的内部方法</p>

<p><a href="http://bubkoo.com/2015/07/24/es6-in-depth-symbols/">深入解析ES6</a></p>

<p><a href="http://www.infoq.com/cn/articles/es6-in-depth-symbols">Symbol介绍</a></p>


</body>

</html>
